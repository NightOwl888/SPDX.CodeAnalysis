name: SPDX.CodeAnalysis

on:
  workflow_dispatch:
  push:
    branches:
      - main
      - 'releases/v*.*'      # matches releases/v1.2
      - 'releases/v*.*.*'    # matches releases/v1.2.3
      - release-workflow
    tags:
      - 'v*'
  pull_request:
  release:
    types: [published]

jobs:
  build:
    if: |
      github.event_name == 'pull_request' ||
      (github.event_name == 'push' &&
      (startsWith(github.ref, 'refs/heads/main') ||
      startsWith(github.ref, 'refs/heads/releases/v') ||
      github.ref_type == 'tag'))
    runs-on: windows-latest
    steps:
      - name: Checkout Source
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup .NET 8.0
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 8.0.x

      - name: Setup .NET 9.0
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 9.0.x

      - name: Restore
        run: dotnet restore

      - name: Build
        shell: pwsh
        run: |
          $nugetOut = "$env:DIST_DIR/nuget"
          dotnet build -c Release --no-restore -p:PackageOutputPath=$nugetOut

      - name: Publish Test Assemblies
        shell: pwsh
        run: |
          $testsOut = "$env:DIST_DIR/testBinaries"
          New-Item -ItemType Directory -Force -Path $testsOut | Out-Null

          # Find all csproj files where a segment is exactly 'Tests'
          Get-ChildItem -Recurse -Filter *.csproj | ForEach-Object {
            Write-Host "Found project: $($_.FullName)"
            $segments = $_.BaseName -split '\.'
            if ($segments -contains 'Tests') {
                $projName = $_.BaseName
                $outDir = Join-Path $testsOut $projName
                New-Item -ItemType Directory -Force -Path $outDir | Out-Null
                Write-Host "Publishing $($_.FullName) -> $outDir"
                dotnet publish $_.FullName -c Release --no-build -o $outDir --verbosity normal
                if ($LASTEXITCODE -ne 0) { throw "Publish failed for $($_.FullName)" }
            }
          }

      - name: Upload NuGet packages
        uses: actions/upload-artifact@v4
        with:
          name: nuget-packages
          path: ${{ env.DIST_DIR }}/nuget

      - name: Upload test assemblies
        uses: actions/upload-artifact@v4
        with:
          name: test-assemblies
          path: ${{ env.DIST_DIR }}/testBinaries
    env:
      DIST_DIR: ${{ github.workspace }}/dist

  test:
    needs: build
    strategy:
      matrix:
        # macos-13 is specifically for running x64, macos-latest for arm64
        os: [windows-latest, ubuntu-latest, macos-13, macos-latest]
        arch: [x64, x86, arm64]
        tfm: [net8.0]
        exclude:
        - arch: x86
          os: ubuntu-latest
        - arch: x86
          os: macos-latest
        - arch: x86
          os: macos-13
        - arch: arm64
          os: macos-13
        - arch: arm64
          os: windows-latest
        - arch: arm64
          os: ubuntu-latest
        - arch: x64
          os: macos-latest
      fail-fast: false

    runs-on: ${{ matrix.os }}

    steps:
      - name: Checkout Source
        uses: actions/checkout@v4

      - name: "Debug: Show checkout location"
        run: |
          echo "GITHUB_WORKSPACE=$GITHUB_WORKSPACE"
          pwd
          ls -la

      # Set up working directories consistently
      - name: Set Paths (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          $dir = "C:\w"
          New-Item -ItemType Directory -Force -Path $dir
          New-Item -ItemType Directory -Force -Path "$dir\temp"
          New-Item -ItemType Directory -Force -Path "$dir\dotnet"
          New-Item -ItemType Directory -Force -Path "$dir\work"
          Add-Content $env:GITHUB_ENV "`nWORKPATH=$dir\work"
          Add-Content $env:GITHUB_ENV "`nTMP=$dir\temp`nTEMP=$dir\temp`nTMPDIR=$dir\temp"
          Add-Content $env:GITHUB_ENV "`nDOTNET_INSTALL_DIR=$dir\dotnet"

      - name: "Debug: Show checkout location"
        run: |
          echo "GITHUB_WORKSPACE=$GITHUB_WORKSPACE"
          pwd
          ls -la

      - name: Set Paths (Linux/macOS)
        if: runner.os == 'Linux' || runner.os == 'macOS'
        shell: pwsh
        run: |
          $dir = "$env:RUNNER_TEMP/w"
          New-Item -ItemType Directory -Force -Path $dir
          New-Item -ItemType Directory -Force -Path "$dir/temp"
          New-Item -ItemType Directory -Force -Path "$dir/dotnet"
          New-Item -ItemType Directory -Force -Path "$dir/work"
          Add-Content $env:GITHUB_ENV "`nWORKPATH=$dir/work"
          Add-Content $env:GITHUB_ENV "`nTMP=$dir/temp`nTEMP=$dir/temp`nTMPDIR=$dir/temp"
          Add-Content $env:GITHUB_ENV "`nDOTNET_INSTALL_DIR=$dir/dotnet"

      # Install the .NET SDK
      - name: Setup .NET 8.0
        if: matrix.arch != 'x86'
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 8.0.x

      - name: Setup .NET 8.0 (x86)
        if: matrix.arch == 'x86'
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 8.0.x
        env:
          PROCESSOR_ARCHITECTURE: x86

      - name: Download Test Binaries
        uses: actions/download-artifact@v4
        with:
          name: test-assemblies
          path: ${{ env.WORKPATH }}

      - name: Copy Coverage Settings to Work Path
        shell: pwsh
        run: |
          $coverageSettings = Join-Path $env:GITHUB_WORKSPACE ".build\coverage.runsettings"
          $dest = Join-Path $env:WORKPATH "coverage.runsettings"
          Write-Host "Copying $coverageSettings to $dest"
          Copy-Item -Path $coverageSettings -Destination $dest -Force

      - name: Install Coverage + Report Tools
        shell: pwsh
        run: |
          dotnet tool install --global dotnet-coverage
          dotnet tool install --global dotnet-reportgenerator-globaltool

          # Ensure the global tools are on PATH for all OS
          if ($env:RUNNER_OS -eq 'Windows') {
            $tools = "$env:USERPROFILE\.dotnet\tools"
          } else {
            $tools = "$env:HOME/.dotnet/tools"
          }
          echo $tools | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append

      - name: Run Tests
        shell: pwsh
        #continue-on-error: true
        run: |
          $resultsRootDir = "$env:WORKPATH/test-results/${{ matrix.os }}-${{ matrix.arch }}-${{ matrix.tfm }}"
          New-Item -ItemType Directory -Force -Path $resultsRootDir | Out-Null

          $results = @()

          Get-ChildItem -Directory $env:WORKPATH | ForEach-Object {
              $dllPath = Join-Path $_.FullName ($_.Name + ".dll")
              $resultsDirectory = Join-Path $resultsRootDir $_.Name
              New-Item -ItemType Directory -Force -Path $resultsDirectory | Out-Null

              if (Test-Path $dllPath) {
                  Write-Host "Running tests in $dllPath"

                  # Ensure a coverage folder per test project output
                  $coverageDir = Join-Path $resultsDirectory "coverage"
                  New-Item -ItemType Directory -Force -Path $coverageDir | Out-Null

                  # Build the inner dotnet test command
                  $testCmd = @(
                    "dotnet", "test", "`"$dllPath`"",
                    "--framework", "${{ matrix.tfm }}",
                    "--logger:`"console;verbosity=normal`"",
                    "--logger:`"trx;LogFileName=TestResults.trx`"",
                    "--results-directory", "`"$resultsDirectory`"",
                    "--blame-hang-timeout", "10m",
                    "--blame-hang-dump-type", "mini",
                    "--blame-crash",
                    "--working-directory", "`"$env:WORKPATH`"",
                    "--", "RunConfiguration.TargetPlatform=${{ matrix.arch }}"
                  ) -join ' '

                  # # Collect coverage in Cobertura format; TRX is produced by the inner 'dotnet test'
                  # dotnet-coverage collect $testCmd `
                  #     --format cobertura `
                  #     --output (Join-Path $coverageDir "coverage.xml") `
                  #     --exclude "'[System.*]*'" `
                  #     --exclude "'[Microsoft.*]*'"

                  # dotnet-coverage collect `
                  #     --settings (Join-Path "$env:GITHUB_WORKSPACE" ".build" "coverage.runsettings") `
                  #     --format cobertura `
                  #     --output (Join-Path $coverageDir "coverage.xml") `
                  #     dotnet test "$dllPath" `
                  #         --framework "${{ matrix.tfm }}" `
                  #         --logger "console;verbosity=normal" `
                  #         --logger "trx;LogFileName=TestResults.trx" `
                  #         --results-directory "$resultsDirectory" `
                  #         --blame-hang-timeout "10m" `
                  #         --blame-hang-dump-type "mini" `
                  #         --blame-crash `
                  #         -- RunConfiguration.TargetPlatform=${{ matrix.arch }}

                  # dotnet-coverage collect `
                  #     dotnet test "$dllPath" `
                  #         --framework "${{ matrix.tfm }}" `
                  #         --logger "console;verbosity=normal" `
                  #         --logger "trx;LogFileName=TestResults.trx" `
                  #         --results-directory "$resultsDirectory" `
                  #         --blame-hang-timeout "10m" `
                  #         --blame-hang-dump-type "mini" `
                  #         --blame-crash `
                  #         -- RunConfiguration.TargetPlatform=${{ matrix.arch }} `
                  #     --output (Join-Path $coverageDir "coverage.xml") `
                  #     --format cobertura `
                  #     --settings (Join-Path "$env:GITHUB_WORKSPACE" ".build" "coverage.runsettings")

                  $coverageRunsettingsFile = Join-Path $env:GITHUB_WORKSPACE ".build"
                  $coverageRunsettingsFile = Join-Path $coverageRunsettingsFile "coverage.runsettings"

                  #$coverageRunsettingsFile = Join-Path $env:WORKPATH "coverage.runsettings"

                  Write-Host "coverageRunsettingsFile: $coverageRunsettingsFile"

                  dotnet-coverage collect "$testCmd" `
                      --settings "$coverageRunsettingsFile" `
                      --format cobertura `
                      --output (Join-Path $coverageDir "coverage.xml") `

                  # TRX inspection / status computation
                  $trxFile = Join-Path $resultsDirectory "TestResults.trx"
                  if (Test-Path $trxFile) {
                      $reader = [System.Xml.XmlReader]::Create($trxFile)
                      try {
                          $countersFound = $false
                          $inRunInfos = $false
                          $crashed = $false
                          $failedCount = 0
                          $passedCount = 0
                          $ignoredCount = 0

                          while ($reader.Read()) {
                              if ($reader.NodeType -eq [System.Xml.XmlNodeType]::Element) {
                                  if (!$countersFound -and $reader.Name -eq 'Counters') {
                                      $failedCount = $reader.GetAttribute('failed')
                                      $passedCount = $reader.GetAttribute('passed')
                                      $ignoredCount = (([int]$reader.GetAttribute('total')) - ([int]$reader.GetAttribute('executed'))).ToString()
                                      $countersFound = $true
                                  }
                                  # Report a crash of the test runner
                                  if ($reader.Name -eq 'RunInfos') {
                                      $inRunInfos = $true
                                  }
                                  if ($inRunInfos -and !$crashed -and $reader.Name -eq 'Text') {
                                      $innerXml = $reader.ReadInnerXml()
                                      # Test for specific error messages - we may need to adjust this, as needed
                                      if ($innerXml -and ($innerXml.Contains('Test host process crashed') `
                                          -or $innerXml.Contains('Could not load file or assembly') `
                                          -or $innerXml.Contains("Could not find `'dotnet.exe`' host") `
                                          -or $innerXml.Contains('No test is available') `
                                          -or $innerXml.Contains('exited with error'))) {

                                          $crashed = $true
                                      }
                                  }
                              }
                              if ($reader.NodeType -eq [System.Xml.XmlNodeType]::EndElement -and $reader.Name -eq 'RunInfos') {
                                  $inRunInfos = $false
                              }
                          }

                          # Determine status for this project
                          if ($crashed) {
                              $statusIcon = '⚠️'; $statusText = 'Crashed'
                          } elseif ($failedCount -gt 0) {
                              $statusIcon = '❌'; $statusText = 'Failed'
                          } else {
                              $statusIcon = '✅'; $statusText = 'Passed'
                          }

                          # Store results
                          $results += [PSCustomObject]@{
                              Project = $_.Name
                              Passed  = $passedCount
                              Failed  = $failedCount
                              Ignored = $ignoredCount
                              Status  = $statusIcon
                              StatusText = $statusText
                          }
                      } finally {
                          $reader.Dispose()
                      }
                  }
              }
          }

          # Write summary
          Add-Content $env:GITHUB_STEP_SUMMARY "## Test Results`n"
          foreach ($r in $results) {
              $line = "- $($r.Status) $($r.StatusText) - **$($r.Project)** | Passed=$($r.Passed), Failed=$($r.Failed), Ignored=$($r.Ignored)"
              Add-Content $env:GITHUB_STEP_SUMMARY $line
          }

          # Generate a per-job coverage summary + HTML reports from all coverage.xml files created above
          $summaryDir = Join-Path $resultsRootDir "coverage-report"
          New-Item -ItemType Directory -Force -Path $summaryDir | Out-Null

          $reportsGlob = Join-Path $resultsRootDir "**/coverage/coverage.xml"
          reportgenerator `
            "-reports:$reportsGlob" `
            "-targetdir:$summaryDir" `
            "-reporttypes:MarkdownSummaryGithub;HtmlInline_AzurePipelines;HtmlChart" `
            "-verbosity:Warning"

          # Append collapsible coverage section to the job summary
          $md = Join-Path $summaryDir "SummaryGithub.md"
          if (Test-Path $md) {
            Add-Content $env:GITHUB_STEP_SUMMARY "`n<details><summary>Coverage</summary>`n"
            Get-Content $md | Add-Content $env:GITHUB_STEP_SUMMARY
            Add-Content $env:GITHUB_STEP_SUMMARY "`n</details>`n"
          } else {
            Write-Host "Coverage summary not generated (no coverage.xml found)."
          }

          # Mark failure state for later steps
          if ($results | Where-Object { $_.Failed -gt 0 -or $_.StatusText -eq 'Crashed' }) {
              Add-Content $env:GITHUB_ENV "`nTESTS_FAILED=true"
          }

      - name: Upload Test Results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results-${{ matrix.os }}-${{ matrix.arch }}
          path: ${{ env.WORKPATH }}/test-results/${{ matrix.os }}-${{ matrix.arch }}-${{ matrix.tfm }}

      - name: Report Test Failure
        if: always() && env.TESTS_FAILED == 'true'
        run: exit 1

  coverage:
    name: Aggregate Coverage
    needs: test
    runs-on: ubuntu-latest
    steps:
      - name: Download all test result artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: test-results-*
          path: all-results
          merge-multiple: true

      # Required for ReportGenerator
      - name: Setup .NET SDK
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 8.0.x

      - name: Install ReportGenerator
        shell: pwsh
        run: |
          dotnet tool install --global dotnet-reportgenerator-globaltool
          echo "$HOME/.dotnet/tools" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append

      - name: Build Aggregate Report
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Force -Path "coverage/aggregate" | Out-Null
          reportgenerator `
            "-reports:all-results/**/coverage/coverage.xml" `
            "-targetdir:coverage/aggregate" `
            "-reporttypes:MarkdownSummaryGithub;HtmlInline_AzurePipelines;HtmlChart" `
            "-verbosity:Warning"

          $md = "coverage/aggregate/SummaryGithub.md"
          if (Test-Path $md) {
            Add-Content $env:GITHUB_STEP_SUMMARY "## Aggregate Coverage`n"
            Get-Content $md | Add-Content $env:GITHUB_STEP_SUMMARY
          } else {
            Add-Content $env:GITHUB_STEP_SUMMARY "## Aggregate Coverage`n_No coverage files found._"
          }

      - name: Upload Aggregate Coverage HTML
        uses: actions/upload-artifact@v4
        with:
          name: coverage-aggregate-html
          path: coverage/aggregate

  release:
    name: Release
    if: github.event_name == 'push' && github.ref_type == 'tag'
    runs-on: ubuntu-latest
    needs:
    - build
    - test
    steps:

      - name: Checkout Source
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # Required for NuGet push
      - name: Setup .NET 8.0
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 8.0.x

      # Determine the release version from the tag
      - name: Get Tag Version
        id: tagversion
        shell: pwsh
        run: |
          $tag = '${{ github.ref_name }}'
          Write-Host "Git tag: $tag"
          # Remove leading 'v' if present
          if ($tag.StartsWith('v')) { $tag = $tag.Substring(1) }
          Write-Host "Version: $tag"
          echo "version=$tag" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8
          # prerelease = true if contains a hyphen (semver prerelease part)
          $prerelease = if ($tag -match '-') { 'true' } else { 'false' }
          echo "prerelease=$prerelease" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append

      - name: Get Version from NBGV
        id: nbgv
        shell: pwsh
        run: |
          $nbgvOutput = & nbgv get-version
          $nugetVersion = ($nbgvOutput | Where-Object { $_ -match '^NuGetPackageVersion:' }) -replace '^NuGetPackageVersion:\s+', ''
          Write-Host "NuGetPackageVersion: $nugetVersion"
          # Export to GitHub Actions
          "version=$nugetVersion" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8

      # Download NuGet artifacts from the build job
      - name: Download NuGet Packages
        uses: actions/download-artifact@v5
        with:
          name: nuget-packages
          path: dist/nuget

      - name: Verify Versions Match
        shell: pwsh
        run: |
          $tagVersion = '${{ steps.tagversion.outputs.version }}'
          $repoVersion = '${{ steps.nbgv.outputs.version }}'

          if ($tagVersion -ne $repoVersion) {
              throw "Tag version $tagVersion does not match repository version $repoVersion. Make sure there are no typos in the Git tag name."
          }

          # Also check that all .nupkg files contain the version
          Get-ChildItem dist/nuget/*.nupkg | ForEach-Object {
              if (-not $_.Name.Contains($tagVersion)) {
                  throw "Artifact version mismatch: $($_.Name) vs tag version $tagVersion"
              }
          }

      - name: Create Draft GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          draft: true
          prerelease: ${{ steps.tagversion.outputs.prerelease }}
          files: dist/nuget/*.nupkg,dist/nuget/*.snupkg
          generate_release_notes: true
          token: ${{ secrets.GITHUB_TOKEN }}

  publish:
    name: publish
    if: github.event_name == 'release' && github.event.action == 'published'
    runs-on: ubuntu-latest
    steps:
      - run: echo "Publishing release artifacts"
  
      - name: Download Release Assets
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require("fs");
            const path = require("path");

            const release = context.payload.release;
            if (!release) {
              core.setFailed("No release payload found.");
              return;
            }

            const assets = release.assets || [];
            const dir = "dist/nuget";
            fs.mkdirSync(dir, { recursive: true });

            for (const asset of assets) {
              if (!asset.name.endsWith(".nupkg") && !asset.name.endsWith(".snupkg")) {
                continue;
              }
              core.info(`Downloading ${asset.name}...`);
              const response = await github.request("GET /repos/{owner}/{repo}/releases/assets/{asset_id}", {
                owner: context.repo.owner,
                repo: context.repo.repo,
                asset_id: asset.id,
                headers: { Accept: "application/octet-stream" },
              });
              const filePath = path.join(dir, asset.name);
              fs.writeFileSync(filePath, Buffer.from(response.data));
              core.info(`Saved to ${filePath}`);
            }
      - name: List Files in dist
        run: find dist -type f
  
      - name: Push To MyGet
        shell: pwsh
        run: |
          $files = Get-ChildItem "dist/nuget/*.nupkg", "dist/nuget/*.snupkg" -ErrorAction Ignore
          foreach ($file in $files) {
              dotnet nuget push $file.FullName --source $env:MYGET_SOURCE_URL --api-key $env:MYGET_API_KEY --skip-duplicate
          }
        env:
          MYGET_SOURCE_URL: ${{ secrets.MYGET_SOURCE_URL }}
          MYGET_API_KEY: ${{ secrets.MYGET_API_KEY }}

      - name: Push To NuGet
        shell: pwsh
        run: |
          $files = Get-ChildItem "dist/nuget/*.nupkg", "dist/nuget/*.snupkg" -ErrorAction Ignore
          foreach ($file in $files) {
              dotnet nuget push $file.FullName --source $env:NUGET_SOURCE_URL --api-key $env:NUGET_API_KEY --skip-duplicate
          }
        env:
          NUGET_SOURCE_URL: 'https://api.nuget.org/v3/index.json'
          NUGET_API_KEY: ${{ secrets.NUGET_API_KEY }}
